/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
/*!*************************!*\
  !*** ./src/dropdown.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MenuBar)
/* harmony export */ });
/**
 * Represents a MenuBar. Contains operations for adding elements to the MenuBar.
 * First, add elements to it using the various add*() methods. Then, use
 * getMenuBar() to get the element reference, which you can use that to append to 
 * a parent of your choice.
 */
class MenuBar {
  
  /**
   * The singleton instance of MenuBar, since only one MenuBar should ever exist on a webpage.
   */
  static #instance;
  /**
   * The menu element.
   * @type {HTMLElement}
   */
  menu;
  /**
   * An array containing all the clickable elements on the menu.
   * @type {HTMLElement[]}
   */
  #clickables;
  #menuItems;

  /**
   * The breakpoint to be set to convert the menu bar to a mobile format. In px.
   * When a MenuBar reference is initialized, the default breakpoint is 860px.
   * @type {MediaQueryList}
   */
  mobileBreakpointListener;

  constructor(className, breakpoint = 860) {
    if (MenuBar.#instance !== undefined) {
      return MenuBar.#instance;
    } 
    MenuBar.#instance = this;

    this.menu = document.createElement("header");
    this.menu.classList.add(className);

    this.#clickables = [];

    this.#menuItems = document.createElement("nav");
    this.#menuItems.classList.add("navigation");

    this.mobileBreakpointListener = window.matchMedia(`(max-width:${breakpoint}px)`);
    this.#initializeResponsiveMenu();

    this.#addHamburgerIcon();
  }

  /**
   * Adds a hamburger icon to clickables.
   */
  #addHamburgerIcon() {
    const svgNs = "http://www.w3.org/2000/svg";
    const container = document.createElementNS(svgNs, "svg");
    container.setAttribute("viewBox", "0 0 100 80");
    container.setAttribute("width", 40);
    container.setAttribute("height", 40);

    for (let i = 0; i < 3; i++) {
      let y = 30 * i;
      const line = document.createElementNS(svgNs, "rect");
      line.setAttribute("width", 100);
      line.setAttribute("height", 20);
      line.setAttribute("y", y);

      container.append(line);
    }

    container.classList.add("menu-icon");

    this.#clickables.push(container);
  }

  /**
   * A helper method which adds classes to a given element.
   * @param {HTMLElement} elem - The element to append classes to.
   * @param {string[]} classNames - The classnames to give the element.
   * @param {string} defaultClass - The classname that said element should always have.
   * */ 
  #addClassesToElement(elem, classNames, defaultClass) {
    classNames.push(defaultClass);
    elem.classList.add(classNames);
  }

  #initializeResponsiveMenu() {
    window.onclick = null;
    this.mobileBreakpointListener.addEventListener("change", (e) => {
      // if the width of the screen is 860px or below...:
      if (e.matches) {
        console.log("mobile breakpoint active, Dan hide menu when clicked off...");
        window.onclick = null;
      } else {
        console.log("mobile breakpoint inactive, collapsing any active menus.");

        document.querySelectorAll(".menubar-dropdown.active")
            .forEach(() => {
              MenuBar.closeActiveDropdown();
            });

        if (window.onclick === null) {
          window.onclick = (e) => {
            const active = document.querySelector(".menubar-dropdown.active");
            // no need to do anything if no dropdown is active.
            if (!active) { 
              return;
            }
            // only close when the element clicked is not the dropdown itself or its child.
            if (!e.target.matches(".menubar-dropdown") && !active.contains(e.target)) {
              MenuBar.closeActiveDropdown();
            }
          };
        }
      }
    });
  }


  /**
   * Create and add a link to the menu.
   * 
   * @param {string} name - The name to be displayed for the link.
   * @param {string} href - The path the link should point to.
   * @param {string[]} className - The class names the link should possess. By
   * default, it obtains the class name 'menu-bar-clickable'.
   */
  addLink(name, href, ...classNames) {
    const link = document.createElement("a");
    
    link.textContent = name;
    link.setAttribute("href", href);
    this.#addClassesToElement(link, classNames, "menubar-link-clickable");

    this.#clickables.push(link);
  }

  /**
   * Create and add a text logo to the menu. Useful for a company logo.
   * 
   * @param {string} text - Accompanying text to display with the icon.
   * @param {string} icon - Filepath representing an icon. Null if you don't need an icon.
   * @param {string[]} classNames - Optional class names the link should possess. By
   * default, it obtains the class name 'menu-bar-clickable'. 
   */
  addLogo(text, icon=null, ...classNames){
    const logo = document.createElement("div");
    const textLogo = document.createElement("h1");
    this.#addClassesToElement(logo, classNames, "site-logo");

    if (icon !== null) {
      const iconElem = document.createElement("img");
      iconElem.setAttribute("src", icon);
      console.log(icon);
      logo.append(iconElem);
    }

    textLogo.textContent = text;

    logo.append(textLogo);

    this.#clickables.push(logo);
  }

  /**
   * Create a dropdown menu based on a given array of links.
   * 
   * @param {string} name - The name of the dropdown menu.
   * @param { {"name" : "href"}[] } links - An array of name:href object pairs.
   * @param {string[]} className - Optional class names the link should possess. By
   * default, it obtains the class name 'menu-bar-clickable'.
   */
  addDropdown(name, links, ...classNames) {
    const dropDownContainer = document.createElement("div");
    // Three components to a dropdown, the label, the navlinks, and the arrow.
    const dropDownLabel = document.createElement("h2");
    const dropDownLinks = document.createElement("ul");
    const dropDownArrow = document.createElement("i");

    this.#addClassesToElement(dropDownContainer, classNames, "menubar-dropdown");
    dropDownLinks.classList.add("dropdown-links", "collapsed");
    dropDownArrow.classList.add("arrow", "down");

    links.forEach((pair) => {
      let linkWrapper = document.createElement("li");
      let link = document.createElement("a");
      
      link.textContent = pair.text;
      link.setAttribute("href", pair.href);

      linkWrapper.classList.add("menubar-dropdown-link");
      linkWrapper.append(link);
      dropDownLinks.append(linkWrapper);
    });
    dropDownLabel.textContent = name;

    dropDownLabel.append(dropDownArrow);
    dropDownContainer.append(dropDownLabel, dropDownLinks);

    dropDownContainer.addEventListener("click", (e) => this.#toggleDropdown.call(this, e));

    this.#clickables.push(dropDownContainer);
  }

  /**
   * Used for closing any active dropdowns, if they're active or the user clicks 
   * any area outside of it on the window.
   */
  static closeActiveDropdown() {
    // If the user clicks anywhere that isn't the current active dropdown...
    const activeDropdownBtn = document.querySelector(".menubar-dropdown.active");
    const activeDropdown = activeDropdownBtn.querySelector(".dropdown-links");
    const activeArrow = activeDropdownBtn.querySelector(".arrow");
    
    // collapse it.
    activeDropdownBtn.classList.remove("active");
    activeDropdown.classList.add("collapsed");
    activeArrow.classList.remove("up");
    activeArrow.classList.add("down");
  }

  /**
   * A callback to show a dropdown menu. Assign this to buttons on the navbar.
   * 
   * @param {*} e - Event. Used to get the current link being hovered over,
   * and then use it to find the dropdown links.
   */
  #toggleDropdown(e) {
    if (!this.mobileBreakpointListener.matches) {
      const activeDropdown = document.querySelector(".menubar-dropdown.active");
      if (activeDropdown !== null && !activeDropdown.contains(e.currentTarget)) {
        MenuBar.closeActiveDropdown();
      }
    }

    const dropdown = e.currentTarget.querySelector("ul");
    const dropdownArrow = e.currentTarget.querySelector(".arrow");
    
    e.currentTarget.classList.toggle("active");
    dropdown.classList.toggle("collapsed");

    dropdownArrow.classList.toggle("down");
    dropdownArrow.classList.toggle("up");
  }

  /**
   * Get the menu with all the clickables that has been added to it.
   * @returns {HTMLElement} - menu.
   */
  getMenu() {
    let self = this;
    this.#clickables.forEach((clickable) => {
      if (clickable.classList.contains("menubar-link-clickable")
          || clickable.classList.contains("menubar-dropdown")) {
            self.#menuItems.append(clickable);
      } else {
        self.menu.append(clickable);
      }
    });

    this.menu.append(this.#menuItems);

    return this.menu;
  }

    /**
   * Add elements to a given menu.
   * 
   * @param {MenuBar} menu - The menu to put elements on.
   * @param {*} elements - The elements to add. Follow a template like navElements.js,
   * as in, an object with a type, text, and href attributes.
   */
  static addElementsToHeader(menu, elements) {
    elements.forEach((elem) => {
      switch (elem.type) {
        case "logo":
          menu.addLogo(elem.text, elem.icon);
          break;
        case "link":
          menu.addLink(elem.text, elem.href);
          break;
        case "dropdown":
          menu.addDropdown(elem.text, elem.links);
          break;
        default: {
          console.log(`${elem.type} has not been implemented yet`);
        }
      }
    });
  }
}

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7O1VBQUE7VUFDQTs7Ozs7V0NEQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxnQkFBZ0IsS0FBSztBQUNwQyxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2J1ZmZpbmctY29tcG9uZW50cy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9idWZmaW5nLWNvbXBvbmVudHMvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2J1ZmZpbmctY29tcG9uZW50cy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2J1ZmZpbmctY29tcG9uZW50cy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2J1ZmZpbmctY29tcG9uZW50cy8uL3NyYy9kcm9wZG93bi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGUgcmVxdWlyZSBzY29wZVxudmFyIF9fd2VicGFja19yZXF1aXJlX18gPSB7fTtcblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgTWVudUJhci4gQ29udGFpbnMgb3BlcmF0aW9ucyBmb3IgYWRkaW5nIGVsZW1lbnRzIHRvIHRoZSBNZW51QmFyLlxyXG4gKiBGaXJzdCwgYWRkIGVsZW1lbnRzIHRvIGl0IHVzaW5nIHRoZSB2YXJpb3VzIGFkZCooKSBtZXRob2RzLiBUaGVuLCB1c2VcclxuICogZ2V0TWVudUJhcigpIHRvIGdldCB0aGUgZWxlbWVudCByZWZlcmVuY2UsIHdoaWNoIHlvdSBjYW4gdXNlIHRoYXQgdG8gYXBwZW5kIHRvIFxyXG4gKiBhIHBhcmVudCBvZiB5b3VyIGNob2ljZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbnVCYXIge1xyXG4gIFxyXG4gIC8qKlxyXG4gICAqIFRoZSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgTWVudUJhciwgc2luY2Ugb25seSBvbmUgTWVudUJhciBzaG91bGQgZXZlciBleGlzdCBvbiBhIHdlYnBhZ2UuXHJcbiAgICovXHJcbiAgc3RhdGljICNpbnN0YW5jZTtcclxuICAvKipcclxuICAgKiBUaGUgbWVudSBlbGVtZW50LlxyXG4gICAqIEB0eXBlIHtIVE1MRWxlbWVudH1cclxuICAgKi9cclxuICBtZW51O1xyXG4gIC8qKlxyXG4gICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIHRoZSBjbGlja2FibGUgZWxlbWVudHMgb24gdGhlIG1lbnUuXHJcbiAgICogQHR5cGUge0hUTUxFbGVtZW50W119XHJcbiAgICovXHJcbiAgI2NsaWNrYWJsZXM7XHJcbiAgI21lbnVJdGVtcztcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGJyZWFrcG9pbnQgdG8gYmUgc2V0IHRvIGNvbnZlcnQgdGhlIG1lbnUgYmFyIHRvIGEgbW9iaWxlIGZvcm1hdC4gSW4gcHguXHJcbiAgICogV2hlbiBhIE1lbnVCYXIgcmVmZXJlbmNlIGlzIGluaXRpYWxpemVkLCB0aGUgZGVmYXVsdCBicmVha3BvaW50IGlzIDg2MHB4LlxyXG4gICAqIEB0eXBlIHtNZWRpYVF1ZXJ5TGlzdH1cclxuICAgKi9cclxuICBtb2JpbGVCcmVha3BvaW50TGlzdGVuZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSwgYnJlYWtwb2ludCA9IDg2MCkge1xyXG4gICAgaWYgKE1lbnVCYXIuI2luc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIE1lbnVCYXIuI2luc3RhbmNlO1xyXG4gICAgfSBcclxuICAgIE1lbnVCYXIuI2luc3RhbmNlID0gdGhpcztcclxuXHJcbiAgICB0aGlzLm1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaGVhZGVyXCIpO1xyXG4gICAgdGhpcy5tZW51LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcclxuXHJcbiAgICB0aGlzLiNjbGlja2FibGVzID0gW107XHJcblxyXG4gICAgdGhpcy4jbWVudUl0ZW1zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm5hdlwiKTtcclxuICAgIHRoaXMuI21lbnVJdGVtcy5jbGFzc0xpc3QuYWRkKFwibmF2aWdhdGlvblwiKTtcclxuXHJcbiAgICB0aGlzLm1vYmlsZUJyZWFrcG9pbnRMaXN0ZW5lciA9IHdpbmRvdy5tYXRjaE1lZGlhKGAobWF4LXdpZHRoOiR7YnJlYWtwb2ludH1weClgKTtcclxuICAgIHRoaXMuI2luaXRpYWxpemVSZXNwb25zaXZlTWVudSgpO1xyXG5cclxuICAgIHRoaXMuI2FkZEhhbWJ1cmdlckljb24oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBoYW1idXJnZXIgaWNvbiB0byBjbGlja2FibGVzLlxyXG4gICAqL1xyXG4gICNhZGRIYW1idXJnZXJJY29uKCkge1xyXG4gICAgY29uc3Qgc3ZnTnMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTnMsIFwic3ZnXCIpO1xyXG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgMTAwIDgwXCIpO1xyXG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDQwKTtcclxuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgNDApO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgIGxldCB5ID0gMzAgKiBpO1xyXG4gICAgICBjb25zdCBsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05zLCBcInJlY3RcIik7XHJcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMTAwKTtcclxuICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMjApO1xyXG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZShcInlcIiwgeSk7XHJcblxyXG4gICAgICBjb250YWluZXIuYXBwZW5kKGxpbmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWVudS1pY29uXCIpO1xyXG5cclxuICAgIHRoaXMuI2NsaWNrYWJsZXMucHVzaChjb250YWluZXIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBoZWxwZXIgbWV0aG9kIHdoaWNoIGFkZHMgY2xhc3NlcyB0byBhIGdpdmVuIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbSAtIFRoZSBlbGVtZW50IHRvIGFwcGVuZCBjbGFzc2VzIHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGNsYXNzTmFtZXMgLSBUaGUgY2xhc3NuYW1lcyB0byBnaXZlIHRoZSBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0Q2xhc3MgLSBUaGUgY2xhc3NuYW1lIHRoYXQgc2FpZCBlbGVtZW50IHNob3VsZCBhbHdheXMgaGF2ZS5cclxuICAgKiAqLyBcclxuICAjYWRkQ2xhc3Nlc1RvRWxlbWVudChlbGVtLCBjbGFzc05hbWVzLCBkZWZhdWx0Q2xhc3MpIHtcclxuICAgIGNsYXNzTmFtZXMucHVzaChkZWZhdWx0Q2xhc3MpO1xyXG4gICAgZWxlbS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZXMpO1xyXG4gIH1cclxuXHJcbiAgI2luaXRpYWxpemVSZXNwb25zaXZlTWVudSgpIHtcclxuICAgIHdpbmRvdy5vbmNsaWNrID0gbnVsbDtcclxuICAgIHRoaXMubW9iaWxlQnJlYWtwb2ludExpc3RlbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgKGUpID0+IHtcclxuICAgICAgLy8gaWYgdGhlIHdpZHRoIG9mIHRoZSBzY3JlZW4gaXMgODYwcHggb3IgYmVsb3cuLi46XHJcbiAgICAgIGlmIChlLm1hdGNoZXMpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm1vYmlsZSBicmVha3BvaW50IGFjdGl2ZSwgRGFuIGhpZGUgbWVudSB3aGVuIGNsaWNrZWQgb2ZmLi4uXCIpO1xyXG4gICAgICAgIHdpbmRvdy5vbmNsaWNrID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm1vYmlsZSBicmVha3BvaW50IGluYWN0aXZlLCBjb2xsYXBzaW5nIGFueSBhY3RpdmUgbWVudXMuXCIpO1xyXG5cclxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLm1lbnViYXItZHJvcGRvd24uYWN0aXZlXCIpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKCgpID0+IHtcclxuICAgICAgICAgICAgICBNZW51QmFyLmNsb3NlQWN0aXZlRHJvcGRvd24oKTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmICh3aW5kb3cub25jbGljayA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgd2luZG93Lm9uY2xpY2sgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLm1lbnViYXItZHJvcGRvd24uYWN0aXZlXCIpO1xyXG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIGRvIGFueXRoaW5nIGlmIG5vIGRyb3Bkb3duIGlzIGFjdGl2ZS5cclxuICAgICAgICAgICAgaWYgKCFhY3RpdmUpIHsgXHJcbiAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG9ubHkgY2xvc2Ugd2hlbiB0aGUgZWxlbWVudCBjbGlja2VkIGlzIG5vdCB0aGUgZHJvcGRvd24gaXRzZWxmIG9yIGl0cyBjaGlsZC5cclxuICAgICAgICAgICAgaWYgKCFlLnRhcmdldC5tYXRjaGVzKFwiLm1lbnViYXItZHJvcGRvd25cIikgJiYgIWFjdGl2ZS5jb250YWlucyhlLnRhcmdldCkpIHtcclxuICAgICAgICAgICAgICBNZW51QmFyLmNsb3NlQWN0aXZlRHJvcGRvd24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbmQgYWRkIGEgbGluayB0byB0aGUgbWVudS5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIHRvIGJlIGRpc3BsYXllZCBmb3IgdGhlIGxpbmsuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgLSBUaGUgcGF0aCB0aGUgbGluayBzaG91bGQgcG9pbnQgdG8uXHJcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gY2xhc3NOYW1lIC0gVGhlIGNsYXNzIG5hbWVzIHRoZSBsaW5rIHNob3VsZCBwb3NzZXNzLiBCeVxyXG4gICAqIGRlZmF1bHQsIGl0IG9idGFpbnMgdGhlIGNsYXNzIG5hbWUgJ21lbnUtYmFyLWNsaWNrYWJsZScuXHJcbiAgICovXHJcbiAgYWRkTGluayhuYW1lLCBocmVmLCAuLi5jbGFzc05hbWVzKSB7XHJcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICBcclxuICAgIGxpbmsudGV4dENvbnRlbnQgPSBuYW1lO1xyXG4gICAgbGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGhyZWYpO1xyXG4gICAgdGhpcy4jYWRkQ2xhc3Nlc1RvRWxlbWVudChsaW5rLCBjbGFzc05hbWVzLCBcIm1lbnViYXItbGluay1jbGlja2FibGVcIik7XHJcblxyXG4gICAgdGhpcy4jY2xpY2thYmxlcy5wdXNoKGxpbmspO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuZCBhZGQgYSB0ZXh0IGxvZ28gdG8gdGhlIG1lbnUuIFVzZWZ1bCBmb3IgYSBjb21wYW55IGxvZ28uXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBBY2NvbXBhbnlpbmcgdGV4dCB0byBkaXNwbGF5IHdpdGggdGhlIGljb24uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGljb24gLSBGaWxlcGF0aCByZXByZXNlbnRpbmcgYW4gaWNvbi4gTnVsbCBpZiB5b3UgZG9uJ3QgbmVlZCBhbiBpY29uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGNsYXNzTmFtZXMgLSBPcHRpb25hbCBjbGFzcyBuYW1lcyB0aGUgbGluayBzaG91bGQgcG9zc2Vzcy4gQnlcclxuICAgKiBkZWZhdWx0LCBpdCBvYnRhaW5zIHRoZSBjbGFzcyBuYW1lICdtZW51LWJhci1jbGlja2FibGUnLiBcclxuICAgKi9cclxuICBhZGRMb2dvKHRleHQsIGljb249bnVsbCwgLi4uY2xhc3NOYW1lcyl7XHJcbiAgICBjb25zdCBsb2dvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIGNvbnN0IHRleHRMb2dvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgxXCIpO1xyXG4gICAgdGhpcy4jYWRkQ2xhc3Nlc1RvRWxlbWVudChsb2dvLCBjbGFzc05hbWVzLCBcInNpdGUtbG9nb1wiKTtcclxuXHJcbiAgICBpZiAoaWNvbiAhPT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBpY29uRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcbiAgICAgIGljb25FbGVtLnNldEF0dHJpYnV0ZShcInNyY1wiLCBpY29uKTtcclxuICAgICAgY29uc29sZS5sb2coaWNvbik7XHJcbiAgICAgIGxvZ28uYXBwZW5kKGljb25FbGVtKTtcclxuICAgIH1cclxuXHJcbiAgICB0ZXh0TG9nby50ZXh0Q29udGVudCA9IHRleHQ7XHJcblxyXG4gICAgbG9nby5hcHBlbmQodGV4dExvZ28pO1xyXG5cclxuICAgIHRoaXMuI2NsaWNrYWJsZXMucHVzaChsb2dvKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIGRyb3Bkb3duIG1lbnUgYmFzZWQgb24gYSBnaXZlbiBhcnJheSBvZiBsaW5rcy5cclxuICAgKiBcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBkcm9wZG93biBtZW51LlxyXG4gICAqIEBwYXJhbSB7IHtcIm5hbWVcIiA6IFwiaHJlZlwifVtdIH0gbGlua3MgLSBBbiBhcnJheSBvZiBuYW1lOmhyZWYgb2JqZWN0IHBhaXJzLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGNsYXNzTmFtZSAtIE9wdGlvbmFsIGNsYXNzIG5hbWVzIHRoZSBsaW5rIHNob3VsZCBwb3NzZXNzLiBCeVxyXG4gICAqIGRlZmF1bHQsIGl0IG9idGFpbnMgdGhlIGNsYXNzIG5hbWUgJ21lbnUtYmFyLWNsaWNrYWJsZScuXHJcbiAgICovXHJcbiAgYWRkRHJvcGRvd24obmFtZSwgbGlua3MsIC4uLmNsYXNzTmFtZXMpIHtcclxuICAgIGNvbnN0IGRyb3BEb3duQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgIC8vIFRocmVlIGNvbXBvbmVudHMgdG8gYSBkcm9wZG93biwgdGhlIGxhYmVsLCB0aGUgbmF2bGlua3MsIGFuZCB0aGUgYXJyb3cuXHJcbiAgICBjb25zdCBkcm9wRG93bkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgyXCIpO1xyXG4gICAgY29uc3QgZHJvcERvd25MaW5rcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcclxuICAgIGNvbnN0IGRyb3BEb3duQXJyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcclxuXHJcbiAgICB0aGlzLiNhZGRDbGFzc2VzVG9FbGVtZW50KGRyb3BEb3duQ29udGFpbmVyLCBjbGFzc05hbWVzLCBcIm1lbnViYXItZHJvcGRvd25cIik7XHJcbiAgICBkcm9wRG93bkxpbmtzLmNsYXNzTGlzdC5hZGQoXCJkcm9wZG93bi1saW5rc1wiLCBcImNvbGxhcHNlZFwiKTtcclxuICAgIGRyb3BEb3duQXJyb3cuY2xhc3NMaXN0LmFkZChcImFycm93XCIsIFwiZG93blwiKTtcclxuXHJcbiAgICBsaW5rcy5mb3JFYWNoKChwYWlyKSA9PiB7XHJcbiAgICAgIGxldCBsaW5rV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcclxuICAgICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuICAgICAgXHJcbiAgICAgIGxpbmsudGV4dENvbnRlbnQgPSBwYWlyLnRleHQ7XHJcbiAgICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBwYWlyLmhyZWYpO1xyXG5cclxuICAgICAgbGlua1dyYXBwZXIuY2xhc3NMaXN0LmFkZChcIm1lbnViYXItZHJvcGRvd24tbGlua1wiKTtcclxuICAgICAgbGlua1dyYXBwZXIuYXBwZW5kKGxpbmspO1xyXG4gICAgICBkcm9wRG93bkxpbmtzLmFwcGVuZChsaW5rV3JhcHBlcik7XHJcbiAgICB9KTtcclxuICAgIGRyb3BEb3duTGFiZWwudGV4dENvbnRlbnQgPSBuYW1lO1xyXG5cclxuICAgIGRyb3BEb3duTGFiZWwuYXBwZW5kKGRyb3BEb3duQXJyb3cpO1xyXG4gICAgZHJvcERvd25Db250YWluZXIuYXBwZW5kKGRyb3BEb3duTGFiZWwsIGRyb3BEb3duTGlua3MpO1xyXG5cclxuICAgIGRyb3BEb3duQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4gdGhpcy4jdG9nZ2xlRHJvcGRvd24uY2FsbCh0aGlzLCBlKSk7XHJcblxyXG4gICAgdGhpcy4jY2xpY2thYmxlcy5wdXNoKGRyb3BEb3duQ29udGFpbmVyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVzZWQgZm9yIGNsb3NpbmcgYW55IGFjdGl2ZSBkcm9wZG93bnMsIGlmIHRoZXkncmUgYWN0aXZlIG9yIHRoZSB1c2VyIGNsaWNrcyBcclxuICAgKiBhbnkgYXJlYSBvdXRzaWRlIG9mIGl0IG9uIHRoZSB3aW5kb3cuXHJcbiAgICovXHJcbiAgc3RhdGljIGNsb3NlQWN0aXZlRHJvcGRvd24oKSB7XHJcbiAgICAvLyBJZiB0aGUgdXNlciBjbGlja3MgYW55d2hlcmUgdGhhdCBpc24ndCB0aGUgY3VycmVudCBhY3RpdmUgZHJvcGRvd24uLi5cclxuICAgIGNvbnN0IGFjdGl2ZURyb3Bkb3duQnRuID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tZW51YmFyLWRyb3Bkb3duLmFjdGl2ZVwiKTtcclxuICAgIGNvbnN0IGFjdGl2ZURyb3Bkb3duID0gYWN0aXZlRHJvcGRvd25CdG4ucXVlcnlTZWxlY3RvcihcIi5kcm9wZG93bi1saW5rc1wiKTtcclxuICAgIGNvbnN0IGFjdGl2ZUFycm93ID0gYWN0aXZlRHJvcGRvd25CdG4ucXVlcnlTZWxlY3RvcihcIi5hcnJvd1wiKTtcclxuICAgIFxyXG4gICAgLy8gY29sbGFwc2UgaXQuXHJcbiAgICBhY3RpdmVEcm9wZG93bkJ0bi5jbGFzc0xpc3QucmVtb3ZlKFwiYWN0aXZlXCIpO1xyXG4gICAgYWN0aXZlRHJvcGRvd24uY2xhc3NMaXN0LmFkZChcImNvbGxhcHNlZFwiKTtcclxuICAgIGFjdGl2ZUFycm93LmNsYXNzTGlzdC5yZW1vdmUoXCJ1cFwiKTtcclxuICAgIGFjdGl2ZUFycm93LmNsYXNzTGlzdC5hZGQoXCJkb3duXCIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBjYWxsYmFjayB0byBzaG93IGEgZHJvcGRvd24gbWVudS4gQXNzaWduIHRoaXMgdG8gYnV0dG9ucyBvbiB0aGUgbmF2YmFyLlxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7Kn0gZSAtIEV2ZW50LiBVc2VkIHRvIGdldCB0aGUgY3VycmVudCBsaW5rIGJlaW5nIGhvdmVyZWQgb3ZlcixcclxuICAgKiBhbmQgdGhlbiB1c2UgaXQgdG8gZmluZCB0aGUgZHJvcGRvd24gbGlua3MuXHJcbiAgICovXHJcbiAgI3RvZ2dsZURyb3Bkb3duKGUpIHtcclxuICAgIGlmICghdGhpcy5tb2JpbGVCcmVha3BvaW50TGlzdGVuZXIubWF0Y2hlcykge1xyXG4gICAgICBjb25zdCBhY3RpdmVEcm9wZG93biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubWVudWJhci1kcm9wZG93bi5hY3RpdmVcIik7XHJcbiAgICAgIGlmIChhY3RpdmVEcm9wZG93biAhPT0gbnVsbCAmJiAhYWN0aXZlRHJvcGRvd24uY29udGFpbnMoZS5jdXJyZW50VGFyZ2V0KSkge1xyXG4gICAgICAgIE1lbnVCYXIuY2xvc2VBY3RpdmVEcm9wZG93bigpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZHJvcGRvd24gPSBlLmN1cnJlbnRUYXJnZXQucXVlcnlTZWxlY3RvcihcInVsXCIpO1xyXG4gICAgY29uc3QgZHJvcGRvd25BcnJvdyA9IGUuY3VycmVudFRhcmdldC5xdWVyeVNlbGVjdG9yKFwiLmFycm93XCIpO1xyXG4gICAgXHJcbiAgICBlLmN1cnJlbnRUYXJnZXQuY2xhc3NMaXN0LnRvZ2dsZShcImFjdGl2ZVwiKTtcclxuICAgIGRyb3Bkb3duLmNsYXNzTGlzdC50b2dnbGUoXCJjb2xsYXBzZWRcIik7XHJcblxyXG4gICAgZHJvcGRvd25BcnJvdy5jbGFzc0xpc3QudG9nZ2xlKFwiZG93blwiKTtcclxuICAgIGRyb3Bkb3duQXJyb3cuY2xhc3NMaXN0LnRvZ2dsZShcInVwXCIpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtZW51IHdpdGggYWxsIHRoZSBjbGlja2FibGVzIHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gaXQuXHJcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fSAtIG1lbnUuXHJcbiAgICovXHJcbiAgZ2V0TWVudSgpIHtcclxuICAgIGxldCBzZWxmID0gdGhpcztcclxuICAgIHRoaXMuI2NsaWNrYWJsZXMuZm9yRWFjaCgoY2xpY2thYmxlKSA9PiB7XHJcbiAgICAgIGlmIChjbGlja2FibGUuY2xhc3NMaXN0LmNvbnRhaW5zKFwibWVudWJhci1saW5rLWNsaWNrYWJsZVwiKVxyXG4gICAgICAgICAgfHwgY2xpY2thYmxlLmNsYXNzTGlzdC5jb250YWlucyhcIm1lbnViYXItZHJvcGRvd25cIikpIHtcclxuICAgICAgICAgICAgc2VsZi4jbWVudUl0ZW1zLmFwcGVuZChjbGlja2FibGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlbGYubWVudS5hcHBlbmQoY2xpY2thYmxlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5tZW51LmFwcGVuZCh0aGlzLiNtZW51SXRlbXMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm1lbnU7XHJcbiAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAqIEFkZCBlbGVtZW50cyB0byBhIGdpdmVuIG1lbnUuXHJcbiAgICogXHJcbiAgICogQHBhcmFtIHtNZW51QmFyfSBtZW51IC0gVGhlIG1lbnUgdG8gcHV0IGVsZW1lbnRzIG9uLlxyXG4gICAqIEBwYXJhbSB7Kn0gZWxlbWVudHMgLSBUaGUgZWxlbWVudHMgdG8gYWRkLiBGb2xsb3cgYSB0ZW1wbGF0ZSBsaWtlIG5hdkVsZW1lbnRzLmpzLFxyXG4gICAqIGFzIGluLCBhbiBvYmplY3Qgd2l0aCBhIHR5cGUsIHRleHQsIGFuZCBocmVmIGF0dHJpYnV0ZXMuXHJcbiAgICovXHJcbiAgc3RhdGljIGFkZEVsZW1lbnRzVG9IZWFkZXIobWVudSwgZWxlbWVudHMpIHtcclxuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW0pID0+IHtcclxuICAgICAgc3dpdGNoIChlbGVtLnR5cGUpIHtcclxuICAgICAgICBjYXNlIFwibG9nb1wiOlxyXG4gICAgICAgICAgbWVudS5hZGRMb2dvKGVsZW0udGV4dCwgZWxlbS5pY29uKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJsaW5rXCI6XHJcbiAgICAgICAgICBtZW51LmFkZExpbmsoZWxlbS50ZXh0LCBlbGVtLmhyZWYpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImRyb3Bkb3duXCI6XHJcbiAgICAgICAgICBtZW51LmFkZERyb3Bkb3duKGVsZW0udGV4dCwgZWxlbS5saW5rcyk7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgJHtlbGVtLnR5cGV9IGhhcyBub3QgYmVlbiBpbXBsZW1lbnRlZCB5ZXRgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=